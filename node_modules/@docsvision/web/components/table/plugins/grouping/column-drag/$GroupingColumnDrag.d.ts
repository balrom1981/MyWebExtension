import { Store } from "effector";
/** Контейнер из котрого, или в который можно перетаскивать элементы. */
export interface IDragContainer<T = unknown> {
    /** Перемещение возможно только между контейнерами в рамках одной области (с одинаковым scope). */
    scope: string;
    /** Уникальный идентификатор контейнера. */
    id: string;
    /** DOM-элемент контейнера. */
    element: HTMLElement;
    /** Функция, определяющая, возможно ли перетаскивание элемента в данный контейнер. */
    onCanAccept?: (dragElement: IDragElement<T>) => boolean;
    /** Функция, вызываемая при перетаскивании элемента в контейнер. */
    onAccept?: (dragElement: IDragElement<T>) => void;
    /** Функция, вызываемая при перетаскивании элемента контейнера за пределы какого-либо контейнера. */
    onRemove?: (dragElement: IDragElement<T>) => void;
    /** Функция, вызываемая при перетаскивании элемента контейнера в другой контейнер. */
    onElementMoved?: (dragElement: IDragElement<T>, targetContainer: IDragContainer<T>) => void;
    /**
     * Функция, вызываемая во время того как элемент перетаскивается на контейнер.
     *
     * @parm dragElement Перетаскиваемый элемент или null, если пользователь вынес элемент за пределы контейнера.
     */
    onElementOver?: (dragElement: IDragElement<T>) => void;
    /**
     * Функция, вызываемая во время того как элемент перетаскивается за пределы контейнера.
     *
     * @parm dragElement Перетаскиваемый элемент.
     */
    onElementOut?: (dragElement: IDragElement<T>) => void;
}
/** Перетаскиваемый элемент. */
export interface IDragElement<T = unknown> {
    /** DOM-элемент. */
    element: Element;
    /** Клон DOM-элемента, который находится возле курсора. */
    elementClone?: Element;
    /** Отображаемое имя элемента. */
    name?: string;
    /** Мета-информация о перетаскиваемой сущности. */
    entity: T;
    /** Контейнер, из которого элемент начали перетаскивать. */
    source: IDragContainer<T>;
}
export interface IDragDetector<T = unknown> {
    /** Область действия детектора. */
    scope: string;
    /** Уникальный идентификатор. */
    id: string;
    /** Контейнер, элементы которого распознает детектор. */
    containerId?: string;
    /** Распознает DOM-элемент как перетаскиваемый элемент. */
    detect: (dragElement: Element, container: IDragContainer<T>, handle?: Element) => IDragElement<T> | null | undefined;
}
export interface IGroupingColumnDragService {
    /** Доступные контейнеры. */
    readonly $containers: Store<IDragContainer[]>;
    /** Текущий перетаскиваемый элемент. */
    readonly $activeDrag: Store<IDragElement | null>;
    /** Состояние перемещения элемента */
    readonly $isDragging: Store<boolean>;
    /** Регистрирует контейнер, содержащий перемещаемые элементы. */
    registerContainer<T>(container: IDragContainer<T>): void;
    /**
     * Регистрирует функцию, которая распознает DOM-элемент контейнера как перемещаемый элемент, разрешая операцию перетаскивания.
     * Если все детекторы возвращают null, то операция перетаскивания отменяется.
     */
    registerDetector<T>(detector: IDragDetector<T>): void;
    /** Удаляет контейнер из обработки. */
    unregisterContainer(id: string): void;
    /** Удаляет детектор из обработки. */
    unregisterDetector<T>(id: string): void;
}
export declare type $GroupingColumnDrag = {
    groupingColumnDrag: IGroupingColumnDragService;
};
export declare const $GroupingColumnDrag: string | ((model?: $GroupingColumnDrag) => IGroupingColumnDragService);
