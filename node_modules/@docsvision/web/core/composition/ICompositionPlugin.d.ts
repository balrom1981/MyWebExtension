import React from "react";
import { IComposition } from '@docsvision/web/core/composition/IComposition';
import { HtmlProps } from "../component";
/** Расположение */
export declare enum PluginPlacement {
    /** С основным содержимым */
    Content = 0,
    /** Слева от основного содержимого */
    BeforeContent = 1,
    /** Справа от основного содержимого */
    AfterContent = 2,
    /** Значение true сигнализирует о том, что плагин является оберткой основного содержимого. */
    ContentWrapper = 3,
    /** Значение true сигнализирует о том, что плагин является оберткой всего содержимого. */
    Wrapper = 4,
    /** Значение true сигнализирует о том, что плагин является самой внешней оберткой всего содержимого. */
    Container = 5
}
/** Определяет порядок расположения элементов с одинаковым выравниванием {@see CompositionPartVerticalAlignment}, {@see CompositionPartHorizontalAlignment}. */
export declare enum CompositionPluginOrder {
    /** Элементы будут расположены в порядке их регистрации. */
    Normal = 0,
    /** Элементы будут помещены ближе к указанному выравниванию, чем остальные (кроме {@see System}). */
    Priority = -100,
    /** Элементы будут помещены ближе к указанному выравниванию, чем остальные. */
    System = -200,
    /** Элементы будут помещены дальше от указанного выравнивания, чем остальные (кроме {@see RevertSystem}). */
    RevertPriority = 100,
    /** Элементы будут помещены дальше от указанного выравнивания, чем остальные. */
    RevertSystem = 200
}
/** Расположение  */
export interface CompositionPluginBoxPlacement {
    align?: PluginPlacement;
    order?: CompositionPluginOrder;
}
export interface CompositionPluginWrapperPlacement {
    isContainer?: boolean;
    isContentWrapper?: boolean;
    isBoxWrapper?: boolean;
}
export declare type CompositionPluginPlacement = CompositionPluginBoxPlacement & CompositionPluginWrapperPlacement;
export declare const DefaultCompositionPartPlacement: CompositionPluginPlacement;
export interface ICompositionPluginProps<CompositionT extends string, DataT = any, ServicesT = any> extends HtmlProps.div {
    composition?: IComposition<CompositionT, DataT, ServicesT>;
}
/** Плагин, заполняющий определенную область композиции. */
export interface IBasicCompositionPlugin<CompositionT extends string> {
    /** Название плагина, для отладки и отличия от других плагинов. */
    name: string;
    /** Назначение плагина. */
    description: string;
    /** Константа, в соответствии с которой объединяются плагины, реализующие одну функциональность. */
    feature: string;
    /** Целевая композиция. */
    composition: CompositionT;
    /** Позволяет временно исключить плагин из обработки. */
    disabled?: boolean;
    /** Порядок среди других компонентов. */
    order?: CompositionPluginOrder;
    /** Из плагинов с одинаковой ролью и расположением будет выбран первый (в порядке приоритетов) вернувший true при вызове {@see shouldRender}. */
    role?: string;
}
/** Плагин, инициализирующий сервисы и выполнящий сервисную логику. */
export interface IServiceProviderPlugin<CompositionT extends string, DataT = any, ServicesT = any> extends IBasicCompositionPlugin<CompositionT> {
    /** Возвращает сервисы, специфичные для данного плагина. */
    addServices?(composition: IComposition<CompositionT, DataT, ServicesT>): void;
}
/** Плагин, заполняющий определенную область композиции. */
export interface IComponentPlugin<CompositionT extends string, DataT = any, ServicesT = any, PropsT = ICompositionPluginProps<CompositionT, DataT, ServicesT>> extends IBasicCompositionPlugin<CompositionT> {
    /** React-компонент, выполняющий отрисовку содержимого плагина. */
    component?: React.ComponentType<PropsT>;
    /** Расположение плагина в композиции. */
    placement?: PluginPlacement;
    /** Метод, позволяющий определить - должен ли плагин быть зайдействован в отрисовке данного содержимого. */
    shouldRender?(composition: IComposition<CompositionT, DataT, ServicesT>): boolean;
    /** Возвращает свойства, которые должны быть переданы в {@see component}. */
    props?(props: PropsT, composition?: IComposition<CompositionT, DataT, ServicesT>): PropsT;
    /** Передавать ли свойство composition в компонент. По умолчанию true. */
    passCompositionProp?: boolean;
    /** Возвращает содержимое, которое должно быть передано в {@see component} в качестве children. */
    children?(defaultChildren: () => React.ReactNode, composition?: IComposition<CompositionT, DataT, ServicesT>): React.ReactNode;
}
/** Плагин, дополняющий компонент, отрендереный другим плагином. */
export interface IDecoratorPlugin<CompositionT extends string, DataT = any, ServicesT = any> extends IBasicCompositionPlugin<CompositionT> {
    /** Функция, осущствляющая преобразование JSX, выполненного основным компонентом. */
    jsxDecorator?: (node: React.ReactNode, composition: IComposition<CompositionT, DataT, ServicesT>) => React.ReactNode;
}
/** Плагин, дополняющий компонент, отрендереный другим плагином. */
export interface IMountEffectPlugin<CompositionT extends string, DataT = any, ServicesT = any> extends IBasicCompositionPlugin<CompositionT> {
    /**
     * Функция, вызываемая после монтирования компонента в DOM.
     *
     * @returns Функцию, вызываемую перед удалением компонента из DOM.
     */
    compositionDidMount?: (composition: IComposition<CompositionT, DataT, ServicesT>) => ((composition: IComposition<CompositionT, DataT, ServicesT>) => void) | void;
}
export interface ICompositionPlugin<DataT = any, ServicesT = any, PropsT = ICompositionPluginProps<any, DataT, ServicesT>> extends IComponentPlugin<any, DataT, ServicesT, PropsT>, IServiceProviderPlugin<any, DataT, ServicesT>, IMountEffectPlugin<any, DataT, ServicesT>, IDecoratorPlugin<any, DataT, ServicesT> {
}
