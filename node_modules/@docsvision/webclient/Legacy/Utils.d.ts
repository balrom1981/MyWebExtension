import { GenModels } from "@docsvision/webclient/Generated/DocsVision.WebClient.Models";
import { IFileCommentsModalProps } from "@docsvision/webclient/Helpers/FileComments/FileCommentsModal";
import { IFilePreviewProps } from "@docsvision/webclient/Helpers/FilePreview/FilePreview";
import { DateTimeFormat } from "@docsvision/webclient/Legacy/DateTimeFormat";
import { $CardId, $CardTimestamp, $ExtendedDataSourceInfos, $RowId } from '@docsvision/webclient/System/LayoutServices';
import { Optional } from "@docsvision/web/core/services";
import { StandardRouteSemantics } from "@docsvision/webclient/System/StandardRouteSemantics";
/** @internal */
export declare class Helpers {
    constructor();
    static GetTarget(event: Event): HTMLElement;
    static GetDateSeparator(): string;
    static HideCaption(): void;
    static ShowCaption(): void;
    static UpdateCaption(headerText?: string, color?: string): void;
    static GetKindNameFromFullString(str: string): string;
    static GetFileExtension(fileName: string): string;
    static SetNumericControl(control: HTMLElement, callback?: Function): void;
    static InsertAfter(newElement: any, targetElement: any): void;
    static CapitalizeFirstLatter(str: string): string;
    static HideLoadingBar(): void;
    /** cspell:ignore toogle */
    private toogle;
    static RunScripts(headerFolderName: HTMLElement): void;
    private static RunScriptsHelper;
    static LoadAndRunScript(url: string): Promise<{}>;
    static DisplayFileSize(fileSize: number): string;
    static CheckCardModified(cardId: string, timestamp: string, callback?: Function): Promise<any>;
    static CheckCardLocked(cardId: string, callback?: Function): Promise<any>;
    static CheckKindCreatable(cardTypeId: string, cardKindId: string, callback: Function): void;
    /**
     * Показать предпросмотр файла.
     * @param options Список опций.
     */
    static ShowFilePreviewDialog(props: IFilePreviewProps, options?: {
        onClose?: () => void;
        onMount?: () => void;
    }): void;
    /**
     * Показать список комментариев файла.
     * @param options Список опций.
     * @returns Функция, вызов которой закрывает модальное окно
     */
    static ShowFileComments(props: IFileCommentsModalProps, options?: {
        onClose?: () => void;
        onShowed?: () => void;
    }): () => void;
    /**
     * Показать окно редактирования имени файла.
     * @returns Функция, вызов которой закрывает модальное окно
     */
    static ShowRenameFileDialog(props: any): () => void;
    static ValidateForm(form: HTMLFormElement): boolean;
    static FindParentElement(headerFolderName: HTMLElement, parentClassName: string): HTMLElement;
    static SuppressEvents(e: Event): void;
    static FloatToCultureStr(num: number, precision?: number): string;
    static ParseFloatCultureStr(str: string): number;
    private static LegacyValidation;
    static Base64Encode(arrayBuffer: any): string;
    static Base64ArrayBuffer(arrayBuffer: any): string;
    static IsEdge(): boolean;
    static SetTooltip(headerFolderName: HTMLElement, extraOptions?: any): void;
    static SetTooltipFor(element: HTMLElement, rawText: string, extraOptions?: any): void;
    static DestroyTooltips(headerFolderName: HTMLElement): void;
    static ClearTips(): void;
    static LocationReload(): void;
    static GetCurrentDeviceType(): GenModels.DeviceType;
    static GetOriginalDeviceType(): GenModels.DeviceType;
    static GetIEVersion(): {
        major: string;
        minor: string;
    };
    static CallCancelableIf(callback: Function, ...args: any[]): Promise<any>;
    static CallIf(callback: Function, ...args: any[]): any;
    static guidPattern: RegExp;
    static validGuid(guid: string): RegExpMatchArray;
    static iterateAsync<T>(collection: T[], func: (item: T) => Promise<any>): Promise<any>;
    private static iterateAsyncNext;
    /** @deprecated В методе нет необходимости, просто приведите к нужному типу. */
    static deferredToPromise<T>(def: Promise<T>): Promise<T>;
    static getHashCode(str: string): number;
    static FindControlOnLayout: (name: string) => any;
    static CheckRouteSemantic: (semantic: StandardRouteSemantics) => boolean;
    static IsGuid(input: string): boolean;
}
export declare function setHtmlElementText(elem: HTMLElement, text: string): void;
export declare function getHtmlElementText(elem: HTMLElement): string;
/** @internal */
export declare class Animate {
    static SetEndCallback(htmlElement: HTMLElement, func: any): void;
}
/** @internal */
export declare class SessionStorage {
    static SupportsSessionStorage(): boolean;
    static SaveData(id: string, obj: any): boolean;
    static LoadData(id: string): any;
}
/** @internal */
export declare class ErrorHelper {
    static ThrowIfElementNotFound(htmlElement: HTMLElement): void;
    static ThrowIfElementIdNotFound(elementWithId: string): void;
    static ThrowIfNull(request: XMLHttpRequest): void;
    static RequestNotSupported(): void;
    static RequestError(errorText: string): void;
    static CertificateNotFound(errorText: string): void;
    static CertificateHasNoPrivateKey(): void;
}
/** Затемнение на весь экран с отображением анимации загрузки. */
export declare class ProgressOverlay {
    private progressOverlay;
    private overlayTimeout;
    private static OverlayElementId;
    /** Таймаут показа затемнения. */
    Timeout: number;
    /** Показывает затемнение через {@link Timeout} мс., если к этому моменту не будет вызван {@link HideOverlay}. */
    ShowOverlay(): void;
    /** Скрыть затемнение. */
    HideOverlay(): void;
    private DestroyOverlay;
    private GetOrCreteateOverlay;
}
/** @internal */
export declare type RequestCustomCompleteCallback = (request: XMLHttpRequest, callerCallback?: Function) => void;
/** @internal */
export declare enum LoadingBarValues {
    Start = 1,
    OneFourth = 25,
    Half = 50,
    AfterHalf = 60,
    ThreeFourth = 75,
    Full = 100,
    None = 0
}
/** Возможные значения для параметра запроса в {@link RequestManager}. */
export declare enum RequestRejectValues {
    /** В функцию reject будет передан текст сообщения об ошибке. */
    ErrorMessage = 0,
    /** В функцию reject будет передан объект ответа. */
    ProcessedResponseObject = 1,
    /** В функцию reject будет передана необработанная строка тела ответа. */
    RawResponseString = 2,
    /** В функцию reject будет передан объект запроса. */
    RequestObject = 3
}
/** Опции создания {@link Request}. */
export interface RequestOptions {
    /** Возвращать полученный ответ без предварительной обработки */
    returnRawResponse?: boolean;
    /** Возвращать полученный ответ ошибки без предварительной обработки */
    returnRawError?: boolean;
    /** Выполнять ли запрос асинхронном режиме (по умолчанию true). */
    isAsync?: boolean;
    /** Отключить кеширование запроса (по умолчанию true). */
    noCache?: boolean;
    /** Показывать ли затемнение на весь экран (по умолчанию false). */
    isShowOverlay?: boolean;
    /** Показывать ли прогресс выполнения запроса в верхней части приложения (по умолчанию true). */
    isShowLoadingBar?: boolean;
    /** При включенной защите от смены роута для запроса не будут вызваны колбэки, если во время выполнения запроса изменился роут. По умолчанию false. */
    disableRouteChangeProtection?: boolean;
    /** Отключает показ диалогов при возникновении ошибок. */
    disableDialogsOnErrors?: boolean;
    /** Значение, которое будет передано в функцию reject при возникновении ошибки в обработке запроса. По умолчанию - ErrorMessage. */
    rejectValue?: RequestRejectValues;
    /** Тип ответа */
    responseType?: XMLHttpRequestResponseType;
    /** Тип передаваемых данных */
    contentType?: string;
    /** Дополнительные заголовки */
    customHeaders?: IRequestHeader[];
    /**
     * При указании данного параметра используются переданные сервисы вместо сервисов разметки.
     *
     * Например, передав собственный сервис $CardTimestamp можно управлять тем, где именно будет обновлен timestamp карточки.
     */
    services?: $CardId & $CardTimestamp & Partial<$ExtendedDataSourceInfos> & Optional<$RowId>;
}
export interface IRequestHeader {
    name: string;
    value: string;
}
/** Обертка вокруг XMLHttpRequest с отображением прогресс-бара и обработкой ошибок. */
export declare class Request {
    private static ActiveRequests;
    private static LoadingBarElementId;
    private static LoadingBarWrapperElementId;
    /** @internal */
    static ContentTypeForm: string;
    private isAsync;
    private responseType;
    private contentType;
    private dataType;
    private isShowOverlay;
    private isShowLoadingBar;
    private customErrorCallback;
    private customCriticalErrorCallback;
    private customCompleteCallback;
    private progressOverlay;
    private isForm;
    private noCache;
    private customHeaders?;
    /** Инициализирует объект. */
    constructor(options?: RequestOptions);
    /** Режим выполнения запроса. */
    get IsAsync(): boolean;
    set IsAsync(value: boolean);
    /** Отключено ли кеширование для запроса. */
    get NoCache(): boolean;
    set NoCache(value: boolean);
    /** Тип данных, передаваемых с запросом. По умолчанию 'application/json; charset=UTF-8;'. */
    set ContentType(value: string);
    get ContentType(): string;
    /** Собственный обработчик ситуации, когда запрос завершился с ошибкой. */
    set CustomErrorCallback(value: Function);
    get CustomErrorCallback(): Function;
    /** Собственный обработчик ситуации, когда запрос завершился с ошибкой. */
    set CustomCriticalErrorCallback(value: Function);
    get CustomCriticalErrorCallback(): Function;
    /** Собственный обработчик успешного завершения запроса. */
    set CustomCompleteCallback(value: RequestCustomCompleteCallback);
    get CustomCompleteCallback(): RequestCustomCompleteCallback;
    /** Тип данных ответа. */
    set ResponseType(value: XMLHttpRequestResponseType);
    get ResponseType(): XMLHttpRequestResponseType;
    /** Отображать ли затемнение экрана во время выполнения запроса. */
    set IsShowOverlay(value: boolean);
    get IsShowOverlay(): boolean;
    /** Отображать ли ход выполнения запроса в верхней части приложения. */
    set IsShowLoadingBar(value: boolean);
    get IsShowLoadingBar(): boolean;
    /** @internal */
    set ShowLoadingBar(value: boolean);
    /** @internal */
    get ShowLoadingBar(): boolean;
    private SetLoadingBar;
    /** Ожидаемый тип возвращаемых с сервера данных. */
    set DataType(value: string);
    /** Отправляет запрос методом POST. */
    PostData(url: string, requestData: any, callback?: Function): void;
    /** Отправляет запрос методом POST. */
    PostDataEx(url: string, requestData: any): Promise<any>;
    /** Отправляет запрос методом POST без обработки ошибок. */
    PostDataSilent(url: string, requestData: any): Promise<any>;
    /** Отправляет запрос методом GET. */
    GetData(url: string, requestData?: any, callback?: Function): void;
    /** Отправляет запрос методом GET. */
    GetDataEx(url: string, requestData?: any): Promise<any>;
    private ProcessRequest;
    private ProcessRequestEx;
    private static ParseError;
    private static GetRequestInstance;
    static unauthorizedConfirmDialog(): void;
}
/** @internal */
export declare class TabsHelper {
    static AddTabEvents(tabElement: HTMLElement): void;
}
/**
 * Утилита для исключения дублирования запуска длительных операций.
 *
 * Для использования необходимо создать экземпляр класса, и запускать операцию
 * через его метод perform. Если на момент вызова операция будет находится в процессе выполнения
 * с предыдущего раза, то вызов будет проигнорирован.
 *
 * Данная логика может быть использована при реализации запросов к серверу при нажатии на кнопку.
 * Использование данной утилиты исключает ситуацию отправки повторного запроса при двойном нажатии
 * кнопки пользователем.
 *
 * Пример использования:
 *
 *      let once = new PerformOnce();
 *      button.addEventListener("click", () => {
 *          once.perform(() => makeServerRequest());
 *      });
 */
export declare class PerformOnce {
    performing: boolean;
    /** Выполняет операцию, если она уже не находится в процессе выполнения. */
    perform(func: () => Promise<any> | Promise<any>): Promise<any>;
}
/** @internal */
export declare class DateTimeHelper {
    static GetLocaleFormat(locale: string): DateTimeFormat;
}
/** @internal */
export declare class EventHelper {
    static Change(headerFolderName: HTMLElement): void;
    static WindowResize(): void;
}
/** @deprecated */
export declare class ComponentBuilder<P, T = any, O = P> {
    static readonly MODIFIER_DELIMITER = "_";
    protected component: any;
    protected mainClassName: string;
    protected additionalClassNames: string;
    protected propsForClasses: {};
    constructor(component: any);
    static createWithProps<CustomInterface = {}>(): <SP, ST, SO>(component: any) => ComponentBuilder<SP & CustomInterface, ST, SO & CustomInterface>;
    setClasses(mainClassName: string, additionalClassNames?: string[] | string): ComponentBuilder<P, T, O>;
    setPropsForClasses(propsForClasses: any): this;
    protected buildClasses: (props: any) => string;
    protected attributeToClassName(attribute: string): string;
    build(): any;
}
