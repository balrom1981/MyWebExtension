import { GenModels } from "@docsvision/webclient/Generated/DocsVision.WebClient.Models";
import { ControlSelector } from "@docsvision/webclient/Helpers/ControlSelector/ControlSelector";
import { PerformOnce } from '@docsvision/webclient/Legacy/Utils';
import { PanelImpl, IPanelState } from "@docsvision/webclient/Platform/PanelImpl";
import { IRowInfo } from "@docsvision/webclient/Platform/IRowInfo";
import { TableColumnWrapper } from "@docsvision/webclient/Platform/TableColumnWrapper";
import { ITableWrapper } from '@docsvision/webclient/Platform/ITableWrapper';
import { Table, TableParams } from "@docsvision/webclient/Platform/Table";
import { SaveCardOptions } from '@docsvision/webclient/System/$Layout';
import { IBindingResult } from "@docsvision/webclient/System/IBindingResult";
import { LoadingState } from "@docsvision/webclient/System/LoadingState";
import React from "react";
/** @internal */
export interface ITableState extends TableParams, IPanelState {
    binding: IBindingResult<GenModels.LayoutTableBindingModel>;
    model: GenModels.LayoutTableBindingModel;
    saveAndReload: () => Promise<Table>;
    saveTable: (options?: SaveCardOptions) => Promise<unknown>;
    tableRows: IRowInfo[];
    newRowTemplate: IRowInfo;
    isExpanded: boolean;
    collapsible: boolean;
    addRowState: LoadingState;
    columnWrappers: TableColumnWrapper[];
    delaySaveMode: boolean;
    header: string;
    tip: string;
    tableOperationModels: GenModels.ControlModel[];
}
export interface TableState extends ITableState {
}
/** @internal */
export declare type TableImplState = ITableState;
/** @internal */
export declare class TableImpl extends PanelImpl<TableParams, ITableState> {
    static BindingNotSpecifiedMetadataKey: string;
    lastTableOperation: Promise<Table>;
    removeRowPerformOnce: PerformOnce;
    private modalHost;
    addRowPerformOnce: PerformOnce;
    constructor(props: TableParams, state: ITableState);
    componentWillUnmount(): void;
    protected prepareChildren(): void;
    parseRows(children: GenModels.ControlModel[]): void;
    setColumnProperty(columnIndex: number, propertyName: string, propertyValue: any): void;
    protected get editMode(): boolean;
    protected onDisclosureClick(): void;
    toggleCollapsed(): void;
    protected onCollapsed(): void;
    protected onExpanded(): void;
    protected canAddRows(): boolean;
    protected canRemoveRows(): boolean;
    protected canEditRows(): boolean;
    protected canSortRows(): boolean;
    bindingConfigured(): boolean;
    get rows(): string[];
    set isCollapsed(val: boolean);
    get isCollapsed(): boolean;
    get columns(): TableColumnWrapper[];
    addRowInternal(scroll?: boolean): Promise<unknown>;
    protected shouldSaveImmediately(): boolean;
    protected onAddRowClick(ev: React.MouseEvent): void;
    showAddRowWindow(): Promise<void>;
    showEditRowWindow(rowId: string): Promise<void>;
    protected isElementInViewport(el: any): boolean;
    /**
     * Проверяет, введены ли какие-либо значения пользователем в контролы указанной строки.
     * Функция может выдавать неверные результаты для нестандартных контролов, поэтому
     * следует использовать ее только там, где это некритично.
     */
    protected checkRowIsEmpty(rowIndex: number): boolean;
    removeRowInternal(rowIndex: number, isEmpty?: boolean): Promise<Table>;
    clear: () => Promise<void>;
    protected onRemoveRowClick(row: IRowInfo): void;
    protected onEditRowClick(row: IRowInfo): void;
    protected getCssClass(): string;
    protected getTableWrapper(): ITableWrapper;
    protected attachOperation: (selector: ControlSelector) => Promise<void>;
    protected renderFileDropHandler(children: JSX.Element): any;
    private renderTableHead;
    private renderTableBody;
    onReorder: (newOrder: any, sortedItems: any) => void;
    getColumnWidth: (colWidth: any) => any;
    renderTableRow(row: IRowInfo, rowIndex: number, canSort: boolean, id: string | number): JSX.Element;
    renderControl(): JSX.Element;
    getRowIndex(rowId: string): number;
}
