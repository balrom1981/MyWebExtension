import { $LayoutCardController } from "@docsvision/webclient/Generated/DocsVision.WebClient.Controllers";
import { GenModels } from "@docsvision/webclient/Generated/DocsVision.WebClient.Models";
import { ModalWindow } from "@docsvision/webclient/Legacy/ModalWindow";
import { $ApplicationTimestamp, $Locale, $SiteUrl } from "@docsvision/webclient/StandardServices";
import { ILayout } from '@docsvision/webclient/System/$Layout';
import { Layout } from "@docsvision/webclient/System/Layout";
import { $CardId, $CardTimestamp, $ExtendedDataSourceInfos, $RowId } from '@docsvision/webclient/System/LayoutServices';
import { LayoutContainer } from "@docsvision/webclient/System/LayoutContainer";
import { PageLeaveConfirmation } from '@docsvision/webclient/System/PageLeaveConfirmation';
import { ServiceContainer } from '@docsvision/web/core/services';
import { CancelableEvent } from "@docsvision/webclient/System/CancelableEvent";
import { ICancelableEvent } from "@docsvision/webclient/System/ICancelableEvent";
import { IEventArgs } from "@docsvision/webclient/System/IEventArgs";
import { SimpleEvent } from "@docsvision/webclient/System/SimpleEvent";
import { ShowLayoutParams } from "@docsvision/webclient/System/ShowLayoutParams";
import { ILayoutManager } from "@docsvision/webclient/System/$LayoutManager";
import { $Router } from '@docsvision/webclient/System/$Router';
/** @internal */
export declare type $MainContentElementId = {
    mainContentElementId: string;
};
export declare const $MainContentElementId: string | ((model?: $MainContentElementId) => string);
export declare type $LayoutManagerServices = $SiteUrl & $ApplicationTimestamp & $LayoutCardController & $Locale & $CardId & $RowId & $CardTimestamp & $Router & $ExtendedDataSourceInfos;
/** Основной класс для отображения разметок и получения к ним доступа. */
export declare class LayoutManager implements ILayoutManager {
    protected services: $LayoutManagerServices;
    protected layoutContainer?: LayoutContainer<GenModels.LayoutViewModel>;
    protected layoutContainers: LayoutContainer<GenModels.LayoutViewModel>[];
    protected layoutCardLayoutPosition: string;
    protected layoutUnloadingEvent: CancelableEvent<ILayout>;
    protected layoutUnloadedEvent: SimpleEvent<ILayout>;
    pageLeaveConfirmation: PageLeaveConfirmation;
    private internalMainContentChange;
    protected prevConfirmationModal: ModalWindow;
    /** @internal */
    constructor(services?: $LayoutManagerServices);
    /** Если в данный момент в Web-клиенте открыта карточка, то возвращает ее разметку. */
    get cardLayout(): Layout | undefined;
    /** Событие, возникающее перед закрытием разметки.  */
    get layoutUnloading(): ICancelableEvent<IEventArgs>;
    /** Событие, возникающее после закрытия разметки.  */
    get layoutUnloaded(): SimpleEvent<IEventArgs>;
    /** Открывает разметку карточки на месте основного содержимого Web-клиента. */
    showCard(model: GenModels.LayoutCardViewModel, name: string, owner?: string, services?: ServiceContainer): Promise<Layout>;
    showRow(model: GenModels.LayoutRowViewModel, name: string, owner?: string, services?: ServiceContainer): Promise<Layout>;
    /** Открывает разметку. */
    showLayout({ root, name, model, owner, layoutPosition, services, uniquePosition }: ShowLayoutParams): Promise<Layout>;
    private checkDuplicates;
    /** Возвращает разметку по имени экземпляра. */
    getLayout(nameOrId: string): Layout | undefined;
    /** Возвращает массив всех разметок. */
    getLayouts(): Layout[] | undefined;
    /** Возвращает имя разметки, заполняющей место основного содержимого Web-клиента. */
    getCurrentLayoutName(): string | undefined;
    /** Возвращает описание разметки по имени экземпляра. */
    getLayoutModel(name: string): GenModels.LayoutViewModel | GenModels.LayoutCardViewModel | GenModels.LayoutRowViewModel | undefined;
    /**
     * Возвращает разметку по id экземпляра.
     * @internal
     */
    getLayoutById(id: string): ILayout | undefined;
    /**
     * Возвращает разметку по HTML элементу.
     * @internal
     */
    getLayoutByHtmlElement(element: HTMLElement): ILayout | undefined;
    /** @internal */
    protected unmountCallback(layoutContainer?: LayoutContainer<GenModels.LayoutViewModel>): void;
    /** @internal */
    protected mountCallback(layoutContainer: LayoutContainer<GenModels.LayoutViewModel>): void;
    /** @internal */
    protected initialize(): void;
    private onMainContentChanging;
    destroyAllUnsaved(showLeaveConfirmationDialog?: boolean): Promise<void>;
    deleteAllUnsaved(synchronous?: boolean): Promise<any>;
    /** Закрывает разметку с указанным именем экземпляра. */
    destroy(nameOrId?: string, showLeaveConfirmationDialog?: boolean): Promise<any>;
    private deleteUnsaved;
    getUnsavedLayouts(): Layout[];
    layoutIsUnsaved(layout: Layout): boolean;
    /** @internal */
    protected onWindowUnload(): Promise<any>;
    /** @deprecated Используйте {@see layoutUnloaded}  */
    get LayoutUnloaded(): SimpleEvent<IEventArgs>;
    /** @internal */
    protected get siteUrl(): string;
    /** Временная метка запуска сервера. */
    protected get applicationTimestamp(): number;
}
export declare let layoutManager: LayoutManager | undefined;
export declare function setLayoutManager(manager: LayoutManager): void;
