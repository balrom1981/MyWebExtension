/// <reference types="webclient-globals" />
import { $LayoutController } from '@docsvision/webclient/Generated/DocsVision.WebClient.Controllers';
import { GenModels } from "@docsvision/webclient/Generated/DocsVision.WebClient.Models";
import { $StandardControllers } from '@docsvision/webclient/Legacy/StandardControllers';
import { Panel, PanelParams } from "@docsvision/webclient/Platform/Panel";
import { $StandardServices } from '@docsvision/webclient/StandardServices';
import { BaseControl, BaseControlParams, BaseControlState, LayoutControl } from "@docsvision/webclient/System/BaseControl";
import { ChangeStateOptions, ILayout, SaveCardOptions } from "@docsvision/webclient/System/$Layout";
import { $ParentOwnerLayout } from "@docsvision/webclient/System/$ParentOwnerLayout";
import { ILayoutBeforeSavingEventArgs, ILayoutParams, ILayoutPrepareSavingEventArgs, ILayoutSavedEventArgs } from "@docsvision/webclient/System/ILayoutParams";
import { LayoutImpl, LayoutState } from "@docsvision/webclient/System/LayoutImpl";
import { ControlWrapperMap } from "@docsvision/webclient/System/ControlWrapperMap";
import { IControlStoreManager } from '@docsvision/webclient/System/IControlStoreManager';
import { IEditOperationStore } from "@docsvision/webclient/System/IEditOperationStore";
import { LayoutContainer } from '@docsvision/webclient/System/LayoutContainer';
import { FieldSpec } from '@docsvision/webclient/System/GetFieldName';
import { BasicApiEvent, CancelableApiEvent } from "@docsvision/webclient/System/ApiEvent";
import { ICardStateChangingEventArgs } from "@docsvision/webclient/System/ICardStateChangingEventArgs";
import { IEventArgs } from "@docsvision/webclient/System/IEventArgs";
import { Optional, ServiceContainer } from '@docsvision/web/core/services';
export declare type LayoutServices = ServiceContainer & $StandardServices & $StandardControllers & Optional<$ParentOwnerLayout> & Optional<$LayoutController>;
/**
 * Публичные свойства для контрола {@link Layout}.
 */
export declare class LayoutParams extends PanelParams implements ILayoutParams {
    /** Стандартный CSS класс со стилями элемента управления. */
    standardCssClass?: string;
    /** Название разметки. */
    layoutName: string;
    /** Дочерние разметки. */
    childLayouts?: Layout[];
    /** URL к картинке фона */
    backgroundImage?: string;
    /** Режим отображения фона */
    backgroundType?: GenModels.BackgroundType;
    /** Стиль отображения фона */
    backgroundStyle?: GenModels.BackgroundStyle;
    /** Запрещает автоматическое удаление карточки/строки при закрытии несохраненной разметки создания */
    disableUnsavedEntityDeletion?: boolean;
    /** Событие возникает при открытии карточки. */
    cardOpening?: CancelableApiEvent<IEventArgs>;
    /** Событие возникает после открытия карточки. */
    cardOpened?: BasicApiEvent<IEventArgs>;
    /** Событие возникает при сохранении карточки после получения значения элементов управления. */
    cardSaving?: CancelableApiEvent<SaveControlDataModelEventArgs>;
    /** Событие возникает при сохранении карточки, до получения значения элементов управления. */
    prepareCardSaving?: CancelableApiEvent<ILayoutPrepareSavingEventArgs>;
    /** Событие возникает при сохранении карточки, до валидации контролов. */
    beforeCardSaving?: CancelableApiEvent<ILayoutBeforeSavingEventArgs>;
    /** Событие возникает после сохранения карточки. */
    cardSaved?: CancelableApiEvent<ILayoutSavedEventArgs>;
    /** Событие возникает, если при сохранении карточки возникли ошибки. */
    cardSaveFailed?: BasicApiEvent<IEventArgs>;
    /** Событие возникает при удалении карточки. */
    cardDeleting?: CancelableApiEvent<IEventArgs>;
    /** Событие возникает после удаления карточки. */
    cardDeleted?: BasicApiEvent<IEventArgs>;
    /** Событие возникает перед изменением состояния карточки. */
    cardStateChanging?: CancelableApiEvent<ICardStateChangingEventArgs>;
    /** Событие возникает перед изменением разметки карточки. */
    cardLayoutSwitching?: CancelableApiEvent<IEventArgs>;
    /** Событие, возникающее после завершения асинхронной подгрузки контролов. */
    allControlsLoaded?: BasicApiEvent<IEventArgs>;
    /** Событие возникает перед изменением разметки карточки. */
    layoutWillUnmount?: BasicApiEvent<IEventArgs>;
    /** @internal */
    mapLayout?: (layoutResolver: () => Layout) => void;
    /** @internal */
    initializationDeferred?: DVPromise<Layout>;
    services?: LayoutServices;
}
export declare type SaveControlDataModelEventArgs = (GenModels.SaveControlDataModel | GenModels.SaveRowControlDataModel | GenModels.SaveRequestModel) & {
    deferred: Promise<any>;
};
/**
 * Класс разметки карточки.
 *
 * Предоставляет доступ к элементам управления, расположенным на разметке, а также методы управления и события карточки.
 */
export declare class Layout extends Panel<LayoutParams, LayoutState> implements ILayout {
    protected lastSaveProcess: Promise<any>;
    constructor(props: LayoutParams);
    /** @internal */
    protected createParams(): LayoutParams;
    /** @internal */
    componentDidMount(): void;
    /** Возвращает элементы управления разметки. */
    get controls(): ControlWrapperMap;
    get controlStoreManager(): IControlStoreManager;
    /** Возвращает модель данных карточки. */
    get cardInfo(): GenModels.CardInfoModel;
    /** Возвращает модель данных строки. */
    get rowInfo(): GenModels.RowInfoModel;
    /** Возвращает модель данных разметки. */
    get layoutInfo(): GenModels.LayoutInfoModel;
    /** Возвращает контейнер разметки. */
    get layoutContainer(): LayoutContainer<any>;
    get childLayouts(): ILayout[];
    get parentLayout(): ILayout;
    /** Предоставляет доступ к хранилищу операций редактирования. */
    get editOperations(): IEditOperationStore;
    /** Возвращает текущую разметку. */
    get layout(): Layout;
    /** Возвращает информацию о связанных источниках данных */
    get extendedDataSourceInfos(): GenModels.ExtendedDataSourceInfoModel[];
    set extendedDataSourceInfos(value: GenModels.ExtendedDataSourceInfoModel[]);
    getService<T>(name?: FieldSpec<any, T>): T;
    /** Возвращает отображаемое название типа карточки. */
    get cardTypeName(): string;
    get isCardLayout(): boolean;
    get isRowLayout(): boolean;
    /** @internal */
    protected get control(): LayoutImpl;
    /**
     * Сохраняет изменения всей разметки (карточки) или конкретного элемента управления.
     * @param control Элемент управления который требуется сохранить. Если не указан, будет сохранена вся разметка.
     * @param doNotMarkAsSaved Флаг, указывающий, что карточка должна сохранить признак "не сохранена": true - карточка остается с признаком "не сохранена",
     * false - карточка сохраняется в обычном режиме.
     */
    saveCard(control?: BaseControl<BaseControlParams, BaseControlState>, doNotMarkAsSaved?: boolean): Promise<any>;
    /**
     * Сохраняет изменения всей разметки (карточки) или конкретного элемента управления.
     * @param control Элемент управления который требуется сохранить. Если не указан, будет сохранена вся разметка.
     * @param options Параметры сохранения.
     */
    saveCardEx(control?: LayoutControl, options?: SaveCardOptions): Promise<void>;
    delete(isCanceling?: boolean): Promise<void>;
    /**
     * Изменяет состояние карточки, по полученной операции редактирования и перезагружает разметку.
     * @param operationId Идентификатор операции редактирования.
     */
    changeState(operationId: string): Promise<any>;
    /**
     * Изменяет состояние карточки, по полученной операции редактирования, не перезагружая разметку.
     * @param operationId Идентификатор операции редактирования.
     */
    changeStateEx(operationId: string, options?: ChangeStateOptions): Promise<any>;
    reloadFromServer(): Promise<this>;
    /**
     * Проверяет, что карточка не заблокирована и не была изменена в другой сессии.
     * @return fail срабатывает, когда карточка заблокирована и есть изменения; иначе - срабатывает done.l.
     */
    checkLockAndModified(): Promise<void>;
    /** @internal */
    protected handleCardOpening(): void;
    /** @internal */
    protected handleCardOpened(): void;
    /** @internal */
    protected handleCardSaving(saveControlData: SaveControlDataModelEventArgs): Promise<any>;
    /** @internal */
    protected handleCardSaved(callback: () => void, args?: ILayoutSavedEventArgs): void;
    /** @internal */
    protected handleCardSaveFailed(): void;
    /** @internal */
    protected handleCardStateChanging(operationId: string, acceptedCallback?: (data?: ICardStateChangingEventArgs) => void, cancelledCallback?: (data?: ICardStateChangingEventArgs) => void): void;
    /** @internal */
    protected handleCardLayoutSwitching(callback: () => void, rejectCallback: () => void): void;
    /**
     * Возвращает флаг, указывающий, что карточка была сохранена после загрузки разметки: true - была сохранена, false - не была сохранена.
     */
    get saved(): boolean;
    /** @internal */
    UNSAFE_componentWillMount(): void;
    /** @internal */
    componentWillUnmount(): Promise<void>;
    /** @internal */
    deinit(): void;
    /** @internal Освобождает дерево компонентов. */
    destroy(): Promise<void>;
    /** @internal */
    protected createImpl(): LayoutImpl;
}
