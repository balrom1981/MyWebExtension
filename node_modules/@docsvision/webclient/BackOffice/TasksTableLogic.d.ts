/// <reference types="react" />
import { GenModels } from '@docsvision/webclient/Generated/DocsVision.WebClient.Models';
import { ITasksTableModel } from '@docsvision/webclient/BackOffice/ITasksTableModel';
import { TasksTableParams } from '@docsvision/webclient/BackOffice/TasksTable';
import { ITasksTableRow } from '@docsvision/webclient/BackOffice/ITasksTableRow';
import { IRenderHelpBoxNodeInfo } from '@docsvision/webclient/BackOffice/ITasksTreeNodeResolver';
import { StaffDirectoryItems } from '@docsvision/webclient/BackOffice/StaffDirectoryItems';
import { ITasksTableSorting } from "@docsvision/webclient/BackOffice/ITaskTableSorting";
export declare class TasksTableLogic {
    options: TasksTableParams;
    constructor(options: TasksTableParams);
    staffDirectoryControl: StaffDirectoryItems;
    domain: 
import("effector").Domain;
    $model: 
import("effector").Store<ITasksTableModel>;
    $rowsCount: 
import("effector").Store<number>;
    loadInitialFx: 
import("effector").Effect<{
        loadFullTree: boolean;
        loadChildren: boolean;
    }, GenModels.TasksTableModel, Error>;
    $initialLoadingFinished: 
import("effector").Store<boolean>;
    loadChildrenRowsFx: 
import("effector").Effect<{
        index: number;
    }, GenModels.TasksTableModel, Error>;
    loadRowsFx: 
import("effector").Effect<number[], GenModels.TasksTableModel, Error>;
    $allChildrenLoaded: 
import("effector").Store<boolean>;
    setData: 
import("effector").Event<{
        rows: ITasksTableRow[];
    }>;
    componentDidMount: 
import("effector").Event<void>;
    $isFullTree: 
import("effector").Store<boolean>;
    showFullTree: 
import("effector").Event<void>;
    showCurrentTaskTree: 
import("effector").Event<void>;
    $canShowFullTree: 
import("effector").Store<boolean>;
    $dialogIsOpen: 
import("effector").Store<boolean>;
    openDialog: 
import("effector").Event<
import("react").MouseEvent<Element, MouseEvent>>;
    closeDialog: 
import("effector").Event<void>;
    $dialogFixed: 
import("effector").Store<boolean>;
    $dialogIsMaximized: 
import("effector").Store<boolean>;
    maximizeDialog: 
import("effector").Event<void>;
    expandRow: 
import("effector").Event<number>;
    collapseRow: 
import("effector").Event<number>;
    toggleRow: 
import("effector").Event<number>;
    toggleRowClass: 
import("effector").Event<{
        row: ITasksTableRow;
        style: string;
    }>;
    taskNameClicked: 
import("effector").Event<{
        row: ITasksTableRow;
    }>;
    taskCellClicked: 
import("effector").Event<{
        event: React.MouseEvent;
        row: ITasksTableRow;
    }>;
    toggleRowClicking: 
import("effector").Event<{
        row: ITasksTableRow;
    }>;
    showHelpBox: 
import("effector").Event<{
        row: ITasksTableRow;
    }>;
    showHelpBoxFx: 
import("effector").Effect<{
        row: ITasksTableRow;
    }, string, Error>;
    hideHelpBox: 
import("effector").Event<{
        row: ITasksTableRow;
    }>;
    $helpBoxRow: 
import("effector").Store<ITasksTableRow>;
    $helpBoxRowInfo: 
import("effector").Store<IRenderHelpBoxNodeInfo>;
    $helpBoxModel: 
import("effector").Store<GenModels.TreeNodeHelpModel>;
    $helpBoxDelegationExpanded: 
import("effector").Store<boolean>;
    helpBoxDelegationClick: 
import("effector").Event<
import("react").MouseEvent<Element, MouseEvent>>;
    loadHelpBoxFx: 
import("effector").Effect<ITasksTableRow, GenModels.TreeNodeHelpModel, Error>;
    expandAll: 
import("effector").Event<
import("react").MouseEvent<Element, MouseEvent>>;
    expandAllLoaded: 
import("effector").Event<void>;
    $expandingAll: 
import("effector").Store<boolean>;
    collapseAll: 
import("effector").Event<
import("react").MouseEvent<Element, MouseEvent>>;
    $maxLevelIdent: 
import("effector").Store<number>;
    refresh: 
import("effector").Event<
import("react").MouseEvent<Element, MouseEvent>>;
    $refreshing: 
import("effector").Store<boolean>;
    showByPerformers: 
import("effector").Event<
import("react").MouseEvent<Element, MouseEvent>>;
    showOverdue: 
import("effector").Event<
import("react").MouseEvent<Element, MouseEvent>>;
    showUnfinished: 
import("effector").Event<
import("react").MouseEvent<Element, MouseEvent>>;
    showFinished: 
import("effector").Event<
import("react").MouseEvent<Element, MouseEvent>>;
    $filter: 
import("effector").Store<(ITasksTableRow: any) => boolean>;
    applyFilter: 
import("effector").Event<{
        filter: (ITasksTableRow: any) => boolean;
        expand: boolean;
    }>;
    toggleFilter: 
import("effector").Event<(ITasksTableRow: any) => boolean>;
    resetFilter: 
import("effector").Event<void>;
    deleteCardFx: 
import("effector").Effect<{
        row: ITasksTableRow;
    }, string, Error>;
    deleteCard: 
import("effector").Event<{
        row: ITasksTableRow;
    }>;
    rowClick: 
import("effector").Event<{
        row: ITasksTableRow;
    }>;
    $searchPerformerSubstring: 
import("effector").Store<string>;
    changeSearchSubstring: 
import("effector").Event<string>;
    cleanSearchSubstring: 
import("effector").Event<
import("react").MouseEvent<Element, MouseEvent>>;
    performerSelected: 
import("effector").Event<string>;
    togglePerformer: 
import("effector").Event<(ITasksTableRow: any) => boolean>;
    $sorting: 
import("effector").Store<ITasksTableSorting>;
    setSorting: 
import("effector").Event<ITasksTableSorting>;
    setModelSorting: 
import("effector").Event<ITasksTableModel>;
    checkItemLoaded(item: ITasksTableRow): boolean;
    smartphoneColumns: GenModels.ColumnDescription[];
    getVisibleColumns(): GenModels.ColumnDescription[];
    getTableMessage(): string;
    setPerformer(searchSubstring: string, performer: string): string;
    clearPerformer(): string;
    performersFilter: (row: ITasksTableRow) => boolean;
    overdueFilter: (row: ITasksTableRow) => boolean;
    finishedFilter: (row: ITasksTableRow) => boolean;
    unfinishedFilter: (row: ITasksTableRow) => boolean;
    rowsToFixateDialog: number;
    init(): void;
    setSortingColumn: (columnType: GenModels.TaskColumnType) => void;
    private getColumns;
    private updateSearchSubstring;
}
